<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>LED Layout Visualization</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            border: 1px solid black;
            display: block;
            margin: auto;
        }

        #controls {
            padding: 10px;
            background: #f0f0f0;
            border-bottom: 1px solid #ccc;
        }

        #controls>div {
            margin: 5px 0;
        }

        label {
            display: inline-block;
            width: 150px;
        }

        .param-description {
            font-size: 0.8em;
            color: #666;
            margin-left: 150px;
        }
    
        #global-params {
            display: none;
        }


        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 5px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
        }

        .modal-content textarea {
            width: 100%;
            height: 300px;
            margin: 10px 0;
        }

        .modal-content button {
            margin: 5px;
        }

        #import-error {
            color: red;
            margin: 10px 0;
        }
    </style>
</head>

<body>
    <div id="controls">
        <div>
            <label for="shader-select">Shader:</label>
            <select id="shader-select"></select>
        </div>
        <div id="shader-params-container"></div>
        <div id="global-params">
            <h3>Global Options</h3>
            <div>
                <label for="global-central-object">Central Object:</label>
                <input type="text" id="global-central-object">
            </div>
            <div>
                <label for="global-center-threshold">Center Threshold:</label>
                <input type="number" id="global-center-threshold" step="0.001" value="0.001">
            </div>
            <div>
                <label for="global-fixed-center-angle">Fixed Center Angle (degrees):</label>
                <input type="number" id="global-fixed-center-angle" step="1" value="0">
            </div>
        </div>

        <div>
            <button id="import-btn">Import CSV</button>
            <button id="export-btn">Export CSV</button>
        </div>

    </div>
    <canvas id="canvas" width="800" height="600"></canvas>

        <!-- Import Modal -->
        <div id="import-modal" class="modal">
            <div class="modal-content">
                <h3>Import CSV</h3>
                <textarea id="import-csv-text" placeholder="Paste CSV data here (label,x,y)"></textarea>
                <div id="import-error"></div>
                <div>
                    <button id="import-submit">Import</button>
                    <button id="import-cancel">Cancel</button>
                </div>
            </div>
        </div>

            <!-- Export Modal -->
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <h3>Export CSV</h3>
            <textarea id="export-csv-text" readonly></textarea>
            <button id="export-close">Close</button>
        </div>
    </div>

    <script>  // Example set of points (label, x, y)
        let points = [
            ['D01', 17.018, 17.018],
            ['D02', 17.018, 8.382],
            ['D03', 21.082, 8.382],
            ['D04', 25.4, 4.318],
            ['D05', 29.718, 8.382],
            ['D06', 33.782, 12.7],
            ['D07', 33.782, 21.082],
            ['D10', 29.718, 29.718],
            ['D12', 17.018, 12.7],
            ['D13', 21.082, 12.7],
            ['D14', 25.4, 8.382],
            ['D15', 29.718, 12.7],
            ['D16', 33.782, 17.018],
            ['D17', 33.782, 25.4],
            ['D20', 25.4, 33.782],
            ['D21', 17.018, 33.782],
            ['D23', 21.082, 17.018],
            ['D24', 25.4, 12.7],
            ['D25', 29.718, 17.018],
            ['D26', 29.718, 21.082],
            ['D27', 29.718, 25.4],
            ['D30', 21.082, 33.782],
            ['D31', 12.7, 33.782],
            ['D32', 8.382, 29.718],
            ['D34', 25.4, 17.018],
            ['D35', 25.4, 21.082],
            ['D36', 25.4, 25.4],
            ['D37', 25.4, 29.718],
            ['D40', 12.7, 29.718],
            ['D41', 8.382, 25.4],
            ['D42', 4.318, 25.4],
            ['D43', 4.318, 21.082],
            ['D45', 21.082, 21.082],
            ['D46', 21.082, 25.4],
            ['D47', 21.082, 29.718],
            ['D50', 12.7, 25.4],
            ['D51', 8.382, 21.082],
            ['D52', 4.318, 17.018],
            ['D53', 4.318, 12.7],
            ['D54', 12.7, 4.318],
            ['D56', 17.018, 29.718],
            ['D57', 17.018, 25.4],
            ['D60', 12.7, 21.082],
            ['D61', 8.382, 17.018],
            ['D62', 8.382, 12.7],
            ['D63', 8.382, 8.382],
            ['D64', 17.018, 4.318],
            ['D65', 21.082, 4.318],
            ['D67', 17.018, 21.082],
            ['D70', 12.7, 17.018],
            ['D71', 12.7, 12.7],
            ['D72', 12.7, 8.382]
        ];

                // Load initial points from localStorage
                (() => {
            try {
                const savedCSV = localStorage.getItem('led-points-csv');
                if (savedCSV) {
                    points = parseCSV(savedCSV);
                } else {
                    savePointsToCSV();
                }
            } catch (e) {
                console.error('Error loading points:', e);
                savePointsToCSV();
            }
        })();

        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const parsedPoints = [];
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;
                const parts = trimmed.split(',').map(p => p.trim());
                if (parts.length !== 3) throw new Error(`Invalid line: ${line}`);
                const label = parts[0];
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                if (isNaN(x) || isNaN(y)) throw new Error(`Invalid numbers in line: ${line}`);
                parsedPoints.push([label, x, y]);
            }
            if (parsedPoints.length === 0) throw new Error('CSV contains no valid data');
            return parsedPoints;
        }

        function savePointsToCSV() {
            const csv = points.map(p => p.join(',')).join('\n');
            localStorage.setItem('led-points-csv', csv);
        }


        // Shader registry implementation
        class ParamType {
            constructor(name, defaultValue, jsType, validator) {
                this.name = name;
                this.defaultValue = defaultValue;
                this.jsType = jsType;
                this.validator = validator;
            }
            validate(value) {
                if (this.jsType && typeof value !== this.jsType) return false;
                return this.validator(value);
            }
        }

        const ParamTypes = Object.freeze({
            NUMBER: new ParamType('NUMBER', 0, 'number', v => typeof v === 'number'),
            INTEGER: new ParamType('INTEGER', 0, 'number', v => Number.isInteger(v)),
            PERCENT: new ParamType('PERCENT', 0, 'number', v => v >= 0 && v <= 1),
            ANGLE: new ParamType('ANGLE', 0, 'number', v => v >= 0 && v <= 2 * Math.PI),
            SHADER: new ParamType('SHADER', 'null', 'string', v => typeof v === 'string')
        });

        class Param {
            constructor(name, paramType, defaultValue, description = null, min = null, max = null, step = null) {
                if (typeof name !== 'string' || !/^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name)) {
                    throw new Error(
                        `Invalid parameter name "${name}". It must be a valid JavaScript identifier (no spaces or special characters).`
                    );
                }
                this.name = name;

                // Sanity check that `type` is one of the defined ParamTypes.
                if (!Object.values(ParamTypes).includes(paramType)) {
                    throw new Error(`Invalid parameter type "${paramType}" for parameter "${name}".`);
                }

                this.paramType = paramType;

                // default value (get from type)
                if (defaultValue === null) {
                    this.defaultValue = paramType.defaultValue;
                } else {
                    this.defaultValue = defaultValue;
                }

                this.description = description;  // optional
                this.min = min;
                this.max = max;
                this.step = step;
            }
        }

        // helper function
        const p = function (name, paramType, defaultValue = null, description = null, { min = null, max = null, step = null } = {}) {
            return new Param(name, paramType, defaultValue, description, min, max, step);
        };

        const shaderRegistry = {};
        function registerShader(name, description, paramDefs, shaderFn) {
            if (typeof name !== 'string') {
                throw new TypeError("Shader name must be a string.");
            }
            if (typeof description !== 'string' && description !== null) {
                throw new TypeError("Shader description must be a string or null.");
            }
            if (!Array.isArray(paramDefs)) {
                throw new TypeError("Shader parameter definitions must be an array.");
            }
            if (typeof shaderFn !== 'function') {
                throw new TypeError("Shader function must be a function.");
            }

            // Optionally, you can also check that each item in paramDefs is a Param object
            paramDefs.forEach(param => {
                if (!(param instanceof Param)) {
                    throw new TypeError("Each parameter definition must be a Param object.");
                }
            });

            shaderRegistry[name] = { params: paramDefs, fn: shaderFn, desc: description };
        }

        // Shader definitions

        // Radial Wave: Modulates the radial angle with a sine wave based on radius.
        registerShader("radial_wave",
            "Applies a sinusoidal variation to the radial angle based on the distance, creating a wave-like effect.",
            [
                p('frequency', ParamTypes.NUMBER, 1.5,
                    "Frequency of the sinusoidal wave along the radius (controls number of cycles per unit distance).",
                    { min: 0, max: null, step: 0.1 }),
                p('amplitude', ParamTypes.PERCENT, 0.5,
                    "Amplitude of the wave, determining the strength of the angular deviation.")
            ],
            (args, params) =>
                args.radial_angle + Math.sin(args.radius * params.frequency) * params.amplitude
        );

        // Perpendicular Rotation: Rotates the angle to be perpendicular to the radial direction.
        registerShader(
            "perpendicular_rotation",
            "Rotates the angle by subtracting the radial angle from 90 degrees, resulting in a perpendicular orientation.",
            [],
            (args) =>
                -args.radial_angle + Math.PI / 2
        );

        // Spiral Rotation: Creates a spiral by increasing the rotation with distance.
        registerShader(
            "spiral_rotation",
            "Rotates the angle to create a spiral pattern, with the rotation incrementally increasing with radius.",
            [
                p('multiplier', ParamTypes.NUMBER, 0.1,
                    "Multiplier that determines how much the angle increases per unit radius, forming the spiral.",
                    { min: 0, max: null, step: 0.01 })
            ],
            (args, params) => args.radial_angle + args.radius * params.multiplier);

        // Compute the centroid of the points.
        function computeCentroid(points, centralObject = null) {
            if (centralObject) {
                for (let [label, x, y] of points) {
                    if (label === centralObject) {
                        return { cx: x, cy: y };
                    }
                }
                throw new Error(`Central object ${centralObject} not found`);
            }
            let sumX = 0, sumY = 0;
            for (let [label, x, y] of points) {
                sumX += x;
                sumY += y;
            }
            return { cx: sumX / points.length, cy: sumY / points.length };
        }

        // Modified calculateAngles function with snake_case args
        function calculateAngles(points, rotationFormula, options = {}) {
            const {
                centralObject = null,
                centerThreshold = 0.001,
                fixedCenterAngle = 0
            } = options;

            const { cx, cy } = computeCentroid(points, centralObject);
            const distances = points.map(([label, x, y]) => Math.hypot(x - cx, y - cy));
            const maxDistance = distances.length ? Math.max(...distances) : 0;

            const result = [];
            for (let i = 0; i < points.length; i++) {
                const [label, x, y] = points[i];
                const dx = x - cx;
                const dy = y - cy;
                const dist = distances[i];

                let angleRad;
                if (dist < centerThreshold) {
                    angleRad = fixedCenterAngle * Math.PI / 180;
                } else {
                    const radialAngle = Math.atan2(dy, dx);
                    angleRad = rotationFormula({
                        radial_angle: radialAngle,
                        radius: dist / maxDistance,
                        dx: dx,
                        dy: dy,
                        label: label
                    });
                }
                let angleDeg = (angleRad * 180 / Math.PI) % 360;
                if (angleDeg < 0) angleDeg += 360;
                result.push({ label, x, y, angleDeg });
            }
            return result;
        }


        // Draw the rotated rectangles on the canvas.
        function visualize(pointsWithAngles, options = {}) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Clear the canvas.
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // For this demo, we define a fixed LED size (in “mm”) and a scale factor.
            // You can adjust these values or add unit conversion as needed.
            const scale = 10;  // 10 pixels per mm
            const ledWidth = 1.6;   // example: 0603 package width in mm
            const ledHeight = 0.8;  // example: 0603 package height in mm

            // For visualization, we translate the coordinate system:
            ctx.save();
            // Translate origin to the center of the canvas.
            ctx.translate(canvas.width / 2, canvas.height / 2);
            // Flip the y-axis so positive y goes up.
            ctx.scale(1, -1);

            // Draw each LED as a rotated rectangle.
            pointsWithAngles.forEach(({ label, x, y, angleDeg }) => {
                // Adjust point positions (here we subtract an offset to roughly center the design).
                const px = (x - 20) * scale;
                const py = (y - 20) * scale;
                const angleRad = angleDeg * Math.PI / 180;

                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(angleRad);
                // Draw a filled rectangle with a stroke.
                ctx.fillStyle = 'blue';
                ctx.strokeStyle = 'black';
                ctx.fillRect(- (ledWidth * scale) / 2, - (ledHeight * scale) / 2, ledWidth * scale, ledHeight * scale);
                ctx.strokeRect(- (ledWidth * scale) / 2, - (ledHeight * scale) / 2, ledWidth * scale, ledHeight * scale);
                ctx.restore();

                // Draw the label near the LED.
                ctx.save();
                ctx.translate(px, py);
                // Since text renders normally, flip the y-axis back.
                ctx.scale(1, -1);
                ctx.fillStyle = 'black';
                ctx.font = "10px Arial";
                ctx.textAlign = 'center';
                // don't show label
                // ctx.fillText(label, 0, 0);
                ctx.restore();
            });

            ctx.restore();
        }

        // UI Management
        function populateShaderSelect() {
            const select = document.getElementById('shader-select');
            const shaderNames = Object.keys(shaderRegistry);

            // Sort the shader names alphabetically
            shaderNames.sort();

            select.innerHTML = shaderNames
                .map(name => `<option value="${name}">${name}</option>`)
                .join('');

            select.dispatchEvent(new Event('change'));
        }

        function populateShaderParams() {
            const container = document.getElementById('shader-params-container');
            container.innerHTML = '';
            const shader = shaderRegistry[document.getElementById('shader-select').value];

            if (shader?.params) {
                shader.params.forEach(param => {
                    const div = document.createElement('div');
                    div.classList.add('param-container');

                    const label = document.createElement('label');
                    label.textContent = `${param.name}: `;

                    const input = document.createElement('input');
                    input.value = param.defaultValue;
                    input.id = `param-${param.name}`;

                    if ((param.min !== null && param.max !== null) || param.paramType === ParamTypes.PERCENT || param.paramType === ParamTypes.ANGLE) {
                        input.type = 'range';
                    } else {
                        input.type = 'number';
                    }
                    if (param.min !== null) input.min = param.min;
                    if (param.max !== null) input.max = param.max;

                    if (param.step !== null) {
                        input.step = param.step;
                    } else if (param.paramType === ParamTypes.INTEGER) {
                        input.step = 1;
                    } else if (param.paramType === ParamTypes.PERCENT) {
                        input.step = .05;
                    }

                    if (param.paramType === ParamTypes.PERCENT) {
                        if (param.min === null) input.min = 0;
                        if (param.max === null) input.max = 1;
                    } else if (param.paramType === ParamTypes.ANGLE) {
                        if (param.min === null) input.min = 0;
                        if (param.max === null) input.max = 2 * Math.PI;
                    }

                    div.appendChild(label);
                    div.appendChild(input);

                    if (param.description) {
                        const description = document.createElement('div');
                        description.classList.add('param-description');
                        description.textContent = param.description;
                        div.appendChild(description);
                    }

                    container.appendChild(div);
                });
            }
        }

        function updateVisualization() {
            const shaderName = document.getElementById('shader-select').value;
            const shader = shaderRegistry[shaderName];
            if (!shader) return;

            const shaderParams = {};
            if (shader.params) {
                shader.params.forEach(param => {
                    const input = document.getElementById(`param-${param.name}`);
                    shaderParams[param.name] = parseFloat(input?.value) || param.defaultValue;
                });
            }

            const globalOptions = {
                centralObject: document.getElementById('global-central-object').value || null,
                centerThreshold: parseFloat(document.getElementById('global-center-threshold').value) || 0.001,
                fixedCenterAngle: parseFloat(document.getElementById('global-fixed-center-angle').value) || 0
            };

            const pointsWithAngles = calculateAngles(points,
                (args) => shader.fn(args, shaderParams),
                globalOptions
            );
            visualize(pointsWithAngles);
        }

         // Modal handling
         document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-csv-text').value = points.map(p => p.join(',')).join('\n');
            document.getElementById('import-error').textContent = '';
            document.getElementById('import-modal').style.display = 'flex';
        });

        document.getElementById('export-btn').addEventListener('click', () => {
            const shaderName = document.getElementById('shader-select').value;
            const shader = shaderRegistry[shaderName];
            if (!shader) return;

            const shaderParams = {};
            shader.params?.forEach(param => {
                const input = document.getElementById(`param-${param.name}`);
                shaderParams[param.name] = parseFloat(input?.value) || param.defaultValue;
            });

            const globalOptions = {
                centralObject: document.getElementById('global-central-object').value || null,
                centerThreshold: parseFloat(document.getElementById('global-center-threshold').value) || 0.001,
                fixedCenterAngle: parseFloat(document.getElementById('global-fixed-center-angle').value) || 0
            };

            const pointsWithAngles = calculateAngles(points, 
                (args) => shader.fn(args, shaderParams), 
                globalOptions
            );
            
            const csv = pointsWithAngles.map(p => 
                `${p.label},${p.angleDeg.toFixed(2)}`
            ).join('\n');
            
            document.getElementById('export-csv-text').value = csv;
            document.getElementById('export-modal').style.display = 'flex';
        });

        document.getElementById('import-submit').addEventListener('click', () => {
            try {
                const newPoints = parseCSV(document.getElementById('import-csv-text').value);
                points = newPoints;
                savePointsToCSV();
                updateVisualization();
                document.getElementById('import-modal').style.display = 'none';
            } catch (e) {
                document.getElementById('import-error').textContent = e.message;
            }
        });

        document.getElementById('import-cancel').addEventListener('click', () => {
            document.getElementById('import-modal').style.display = 'none';
        });

        document.getElementById('export-close').addEventListener('click', () => {
            document.getElementById('export-modal').style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });

        // Initial setup
        document.getElementById('shader-select').addEventListener('change', populateShaderParams);
        document.getElementById('controls').addEventListener('input', updateVisualization);
        populateShaderSelect();
        updateVisualization();
    </script>
</body>

</html>